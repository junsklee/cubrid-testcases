===================================================
0
===================================================
0
===================================================
0
===================================================
4
===================================================
0
===================================================
0
===================================================
0
===================================================
0
===================================================
0
===================================================
    
####  1. hint: recompile ordered use_hash     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: hash-join (inner join)
                 edge:  term[?]
                 outer: hash-join (inner join)
                            edge:  term[?]
                            outer: hash-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED USE_HASH */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
####  2. hint: recompile ordered use_hash(a)     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: nl-join (inner join)
                 edge:  term[?]
                 outer: nl-join (inner join)
                            edge:  term[?]
                            outer: nl-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  sargs: term[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       sargs: term[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            sargs: term[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED USE_HASH(a) */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
####  3. hint: recompile ordered use_hash(b)     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: nl-join (inner join)
                 edge:  term[?]
                 outer: nl-join (inner join)
                            edge:  term[?]
                            outer: hash-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       sargs: term[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            sargs: term[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED USE_HASH(b) */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
####  4. hint: recompile ordered use_hash(c)     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: nl-join (inner join)
                 edge:  term[?]
                 outer: hash-join (inner join)
                            edge:  term[?]
                            outer: nl-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  sargs: term[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            sargs: term[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED USE_HASH(c) */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
####  5. hint: recompile ordered use_hash(d)     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: hash-join (inner join)
                 edge:  term[?]
                 outer: nl-join (inner join)
                            edge:  term[?]
                            outer: nl-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  sargs: term[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       sargs: term[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED USE_HASH(d) */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
####  6. hint: recompile ordered use_hash no_use_hash     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: nl-join (inner join)
                 edge:  term[?]
                 outer: nl-join (inner join)
                            edge:  term[?]
                            outer: nl-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  sargs: term[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       sargs: term[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            sargs: term[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED NO_USE_HASH USE_HASH */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
####  7. hint: recompile ordered use_hash no_use_hash(a)     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: hash-join (inner join)
                 edge:  term[?]
                 outer: hash-join (inner join)
                            edge:  term[?]
                            outer: hash-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED NO_USE_HASH(a) USE_HASH */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
####  8. hint: recompile ordered use_hash no_use_hash(b)     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: hash-join (inner join)
                 edge:  term[?]
                 outer: hash-join (inner join)
                            edge:  term[?]
                            outer: nl-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  sargs: term[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED NO_USE_HASH(b) USE_HASH */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
####  9. hint: recompile ordered use_hash no_use_hash(c)     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: hash-join (inner join)
                 edge:  term[?]
                 outer: nl-join (inner join)
                            edge:  term[?]
                            outer: hash-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       sargs: term[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED NO_USE_HASH(c) USE_HASH */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
#### 10. hint: recompile ordered use_hash no_use_hash(d)     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: nl-join (inner join)
                 edge:  term[?]
                 outer: hash-join (inner join)
                            edge:  term[?]
                            outer: hash-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            sargs: term[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED NO_USE_HASH(d) USE_HASH */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
#### 11. hint: recompile ordered use_hash(a,b) no_use_hash(c,d)     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: nl-join (inner join)
                 edge:  term[?]
                 outer: nl-join (inner join)
                            edge:  term[?]
                            outer: hash-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       sargs: term[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            sargs: term[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED NO_USE_HASH(c, d) USE_HASH(a, b) */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
#### 12. hint: recompile ordered use_hash(a,c) no_use_hash(b,d)     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: nl-join (inner join)
                 edge:  term[?]
                 outer: hash-join (inner join)
                            edge:  term[?]
                            outer: nl-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  sargs: term[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            sargs: term[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED NO_USE_HASH(b, d) USE_HASH(a, c) */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
#### 13. hint: recompile ordered use_hash(a,b,c) no_use_hash(b,d)     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: nl-join (inner join)
                 edge:  term[?]
                 outer: hash-join (inner join)
                            edge:  term[?]
                            outer: nl-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  sargs: term[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            sargs: term[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED NO_USE_HASH(b, d) USE_HASH(a, b, c) */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
    
#### 14. hint: recompile ordered use_hash(b,c,d) no_use_hash(b,c,d)     

===================================================
a_ca    b_ca    c_ca    d_ca    
1     1     1     1     
2     2     2     2     
3     3     3     3     
4     4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: [1]
seg[3]: ca[1] (f)
seg[4]: [2]
seg[5]: ca[2] (f)
seg[6]: [3]
seg[7]: ca[3] (f)
Join graph nodes:
node[0]: dba.ta a(4/1) (loc 0)
node[1]: dba.tb b(4/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(4/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(4/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: nl-join (inner join)
                 edge:  term[?]
                 outer: nl-join (inner join)
                            edge:  term[?]
                            outer: nl-join (inner join)
                                       edge:  term[?]
                                       outer: sscan
                                                  class: a node[?]
                                                  cost:  ? card ?
                                       inner: sscan
                                                  class: b node[?]
                                                  sargs: term[?]
                                                  cost:  ? card ?
                                       cost:  ? card ?
                            inner: sscan
                                       class: c node[?]
                                       sargs: term[?]
                                       cost:  ? card ?
                            cost:  ? card ?
                 inner: sscan
                            class: d node[?]
                            sargs: term[?]
                            cost:  ? card ?
                 cost:  ? card ?
    sort:  ? asc
    cost:  ? card ?
Query stmt:
select /*+ ORDERED NO_USE_HASH(b, c, d) USE_HASH(b, c, d) */ a.ca, b.ca, c.ca, d.ca from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca order by ?
===================================================
0
===================================================
0
