===================================================
0
===================================================
0
===================================================
0
===================================================
8
===================================================
0
===================================================
0
===================================================
0
===================================================
0
===================================================
0
===================================================
0
===================================================
    
####  1. hint: recompile ordered use_hash     

===================================================
4
===================================================
12
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
hash-join (inner join)
    edge:  term[2]
    outer: hash-join (inner join)
               edge:  term[1]
               outer: hash-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     cost:  1 card 8
                          cost:  3 card 8
               inner: sscan
                          class: c node[2]
                          cost:  1 card 8
               cost:  5 card 8
    inner: sscan
               class: d node[3]
               cost:  1 card 8
    cost:  7 card 8
Query stmt:
select /*+ ORDERED USE_HASH */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     1     1     1     1     
2     1     1     1     1     
3     1     1     1     1     
4     1     1     1     1     
5     null     null     null     null     
6     null     null     null     null     
7     null     null     null     null     
8     null     null     null     null     

===================================================
0
===================================================
0
===================================================
    
####  2. hint: recompile ordered use_hash(a)     

===================================================
1
===================================================
3
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
nl-join (inner join)
    edge:  term[2]
    outer: nl-join (inner join)
               edge:  term[1]
               outer: nl-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     sargs: term[0]
                                     cost:  1 card 8
                          cost:  109 card 8
               inner: sscan
                          class: c node[2]
                          sargs: term[1]
                          cost:  1 card 8
               cost:  217 card 8
    inner: sscan
               class: d node[3]
               sargs: term[2]
               cost:  1 card 8
    cost:  326 card 8
Query stmt:
select /*+ ORDERED USE_HASH(a) */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     1     1     1     1     
2     null     null     null     null     
3     null     null     null     null     
4     null     null     null     null     
5     null     null     null     null     
6     null     null     null     null     
7     null     null     null     null     
8     null     null     null     null     

===================================================
0
===================================================
0
===================================================
    
####  3. hint: recompile ordered use_hash(b)     

===================================================
1
===================================================
3
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
nl-join (inner join)
    edge:  term[2]
    outer: nl-join (inner join)
               edge:  term[1]
               outer: hash-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     cost:  1 card 8
                          cost:  3 card 8
               inner: sscan
                          class: c node[2]
                          sargs: term[1]
                          cost:  1 card 8
               cost:  111 card 8
    inner: sscan
               class: d node[3]
               sargs: term[2]
               cost:  1 card 8
    cost:  219 card 8
Query stmt:
select /*+ ORDERED USE_HASH(b) */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     null     null     null     null     
2     1     1     1     1     
3     null     null     null     null     
4     null     null     null     null     
5     null     null     null     null     
6     null     null     null     null     
7     null     null     null     null     
8     null     null     null     null     

===================================================
0
===================================================
0
===================================================
    
####  4. hint: recompile ordered use_hash(c)     

===================================================
1
===================================================
3
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
nl-join (inner join)
    edge:  term[2]
    outer: hash-join (inner join)
               edge:  term[1]
               outer: nl-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     sargs: term[0]
                                     cost:  1 card 8
                          cost:  109 card 8
               inner: sscan
                          class: c node[2]
                          cost:  1 card 8
               cost:  111 card 8
    inner: sscan
               class: d node[3]
               sargs: term[2]
               cost:  1 card 8
    cost:  219 card 8
Query stmt:
select /*+ ORDERED USE_HASH(c) */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     null     null     null     null     
2     null     null     null     null     
3     1     1     1     1     
4     null     null     null     null     
5     null     null     null     null     
6     null     null     null     null     
7     null     null     null     null     
8     null     null     null     null     

===================================================
0
===================================================
0
===================================================
    
####  5. hint: recompile ordered use_hash(d)     

===================================================
1
===================================================
3
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
hash-join (inner join)
    edge:  term[2]
    outer: nl-join (inner join)
               edge:  term[1]
               outer: nl-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     sargs: term[0]
                                     cost:  1 card 8
                          cost:  109 card 8
               inner: sscan
                          class: c node[2]
                          sargs: term[1]
                          cost:  1 card 8
               cost:  217 card 8
    inner: sscan
               class: d node[3]
               cost:  1 card 8
    cost:  219 card 8
Query stmt:
select /*+ ORDERED USE_HASH(d) */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     null     null     null     null     
2     null     null     null     null     
3     null     null     null     null     
4     1     1     1     1     
5     null     null     null     null     
6     null     null     null     null     
7     null     null     null     null     
8     null     null     null     null     

===================================================
0
===================================================
0
===================================================
    
####  6. hint: recompile ordered use_hash no_use_hash     

===================================================
8
===================================================
24
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
nl-join (inner join)
    edge:  term[2]
    outer: nl-join (inner join)
               edge:  term[1]
               outer: nl-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     sargs: term[0]
                                     cost:  1 card 8
                          cost:  109 card 8
               inner: sscan
                          class: c node[2]
                          sargs: term[1]
                          cost:  1 card 8
               cost:  217 card 8
    inner: sscan
               class: d node[3]
               sargs: term[2]
               cost:  1 card 8
    cost:  326 card 8
Query stmt:
select /*+ ORDERED NO_USE_HASH USE_HASH */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     1     1     1     1     
2     1     1     1     1     
3     1     1     1     1     
4     1     1     1     1     
5     1     1     1     1     
6     1     1     1     1     
7     1     1     1     1     
8     1     1     1     1     

===================================================
0
===================================================
0
===================================================
    
####  7. hint: recompile ordered use_hash no_use_hash(a)     

===================================================
5
===================================================
15
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
hash-join (inner join)
    edge:  term[2]
    outer: hash-join (inner join)
               edge:  term[1]
               outer: hash-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     cost:  1 card 8
                          cost:  3 card 8
               inner: sscan
                          class: c node[2]
                          cost:  1 card 8
               cost:  5 card 8
    inner: sscan
               class: d node[3]
               cost:  1 card 8
    cost:  7 card 8
Query stmt:
select /*+ ORDERED NO_USE_HASH(a) USE_HASH */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     1     1     1     1     
2     1     1     1     1     
3     1     1     1     1     
4     1     1     1     1     
5     1     1     1     1     
6     null     null     null     null     
7     null     null     null     null     
8     null     null     null     null     

===================================================
0
===================================================
0
===================================================
    
####  8. hint: recompile ordered use_hash no_use_hash(b)     

===================================================
5
===================================================
15
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
hash-join (inner join)
    edge:  term[2]
    outer: hash-join (inner join)
               edge:  term[1]
               outer: nl-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     sargs: term[0]
                                     cost:  1 card 8
                          cost:  109 card 8
               inner: sscan
                          class: c node[2]
                          cost:  1 card 8
               cost:  111 card 8
    inner: sscan
               class: d node[3]
               cost:  1 card 8
    cost:  113 card 8
Query stmt:
select /*+ ORDERED NO_USE_HASH(b) USE_HASH */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     1     1     1     1     
2     1     1     1     1     
3     1     1     1     1     
4     1     1     1     1     
5     null     null     null     null     
6     1     1     1     1     
7     null     null     null     null     
8     null     null     null     null     

===================================================
0
===================================================
0
===================================================
    
####  9. hint: recompile ordered use_hash no_use_hash(c)     

===================================================
5
===================================================
15
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
hash-join (inner join)
    edge:  term[2]
    outer: nl-join (inner join)
               edge:  term[1]
               outer: hash-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     cost:  1 card 8
                          cost:  3 card 8
               inner: sscan
                          class: c node[2]
                          sargs: term[1]
                          cost:  1 card 8
               cost:  111 card 8
    inner: sscan
               class: d node[3]
               cost:  1 card 8
    cost:  113 card 8
Query stmt:
select /*+ ORDERED NO_USE_HASH(c) USE_HASH */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     1     1     1     1     
2     1     1     1     1     
3     1     1     1     1     
4     1     1     1     1     
5     null     null     null     null     
6     null     null     null     null     
7     1     1     1     1     
8     null     null     null     null     

===================================================
0
===================================================
0
===================================================
    
#### 10. hint: recompile ordered use_hash no_use_hash(d)     

===================================================
5
===================================================
15
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
nl-join (inner join)
    edge:  term[2]
    outer: hash-join (inner join)
               edge:  term[1]
               outer: hash-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     cost:  1 card 8
                          cost:  3 card 8
               inner: sscan
                          class: c node[2]
                          cost:  1 card 8
               cost:  5 card 8
    inner: sscan
               class: d node[3]
               sargs: term[2]
               cost:  1 card 8
    cost:  113 card 8
Query stmt:
select /*+ ORDERED NO_USE_HASH(d) USE_HASH */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     1     1     1     1     
2     1     1     1     1     
3     1     1     1     1     
4     1     1     1     1     
5     null     null     null     null     
6     null     null     null     null     
7     null     null     null     null     
8     1     1     1     1     

===================================================
0
===================================================
0
===================================================
    
#### 11. hint: recompile ordered use_hash(a,b) no_use_hash(c,d)     

===================================================
4
===================================================
12
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
nl-join (inner join)
    edge:  term[2]
    outer: nl-join (inner join)
               edge:  term[1]
               outer: hash-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     cost:  1 card 8
                          cost:  3 card 8
               inner: sscan
                          class: c node[2]
                          sargs: term[1]
                          cost:  1 card 8
               cost:  111 card 8
    inner: sscan
               class: d node[3]
               sargs: term[2]
               cost:  1 card 8
    cost:  219 card 8
Query stmt:
select /*+ ORDERED NO_USE_HASH(c, d) USE_HASH(a, b) */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     1     1     1     1     
2     1     1     1     1     
3     null     null     null     null     
4     null     null     null     null     
5     null     null     null     null     
6     null     null     null     null     
7     1     1     1     1     
8     1     1     1     1     

===================================================
0
===================================================
0
===================================================
    
#### 12. hint: recompile ordered use_hash(a,c) no_use_hash(b,d)     

===================================================
4
===================================================
12
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
nl-join (inner join)
    edge:  term[2]
    outer: hash-join (inner join)
               edge:  term[1]
               outer: nl-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     sargs: term[0]
                                     cost:  1 card 8
                          cost:  109 card 8
               inner: sscan
                          class: c node[2]
                          cost:  1 card 8
               cost:  111 card 8
    inner: sscan
               class: d node[3]
               sargs: term[2]
               cost:  1 card 8
    cost:  219 card 8
Query stmt:
select /*+ ORDERED NO_USE_HASH(b, d) USE_HASH(a, c) */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     1     1     1     1     
2     null     null     null     null     
3     1     1     1     1     
4     null     null     null     null     
5     null     null     null     null     
6     1     1     1     1     
7     null     null     null     null     
8     1     1     1     1     

===================================================
0
===================================================
0
===================================================
    
#### 13. hint: recompile ordered use_hash(a,b,c) no_use_hash(b,d)     

===================================================
5
===================================================
15
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
nl-join (inner join)
    edge:  term[2]
    outer: hash-join (inner join)
               edge:  term[1]
               outer: nl-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     sargs: term[0]
                                     cost:  1 card 8
                          cost:  109 card 8
               inner: sscan
                          class: c node[2]
                          cost:  1 card 8
               cost:  111 card 8
    inner: sscan
               class: d node[3]
               sargs: term[2]
               cost:  1 card 8
    cost:  219 card 8
Query stmt:
select /*+ ORDERED NO_USE_HASH(b, d) USE_HASH(a, b, c) */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     1     1     1     1     
2     1     1     1     1     
3     1     1     1     1     
4     null     null     null     null     
5     null     null     null     null     
6     1     1     1     1     
7     null     null     null     null     
8     1     1     1     1     

===================================================
0
===================================================
0
===================================================
    
#### 14. hint: recompile ordered use_hash(b,c,d) no_use_hash(b,c,d)     

===================================================
6
===================================================
18
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0]
seg[2]: flag[0]
seg[3]: [1] (f)
seg[4]: ca[1]
seg[5]: [2] (f)
seg[6]: ca[2]
seg[7]: [3] (f)
seg[8]: ca[3]
Join graph nodes:
node[0]: dba.ta a(8/1) (sargs 3) (loc 0)
node[1]: dba.tb b(8/1) (outer-dep-set 0) (loc 1)
node[2]: dba.tc c(8/1) (outer-dep-set 0 1) (loc 2)
node[3]: dba.td d(8/1) (outer-dep-set 0 1 2) (loc 3)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2] ca[3]
Join graph edges:
term[0]: a.ca=b.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: b.ca=c.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[2]: c.ca=d.ca (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[3]: a.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
nl-join (inner join)
    edge:  term[2]
    outer: nl-join (inner join)
               edge:  term[1]
               outer: nl-join (inner join)
                          edge:  term[0]
                          outer: sscan
                                     class: a node[0]
                                     sargs: term[3]
                                     cost:  1 card 8
                          inner: sscan
                                     class: b node[1]
                                     sargs: term[0]
                                     cost:  1 card 8
                          cost:  109 card 8
               inner: sscan
                          class: c node[2]
                          sargs: term[1]
                          cost:  1 card 8
               cost:  217 card 8
    inner: sscan
               class: d node[3]
               sargs: term[2]
               cost:  1 card 8
    cost:  326 card 8
Query stmt:
select /*+ ORDERED NO_USE_HASH(b, c, d) USE_HASH(b, c, d) */ d,class d,c,class c,b,class b, ?:1  as [b.flag], ?:2  as [c.flag], ?:3  as [d.flag] from ta a, tb b, tc c, td d where a.ca=b.ca and b.ca=c.ca and c.ca=d.ca and a.flag= ?:0 
===================================================
a_ca    a_flag    b_flag    c_flag    d_flag    
1     null     null     null     null     
2     1     1     1     1     
3     1     1     1     1     
4     1     1     1     1     
5     null     null     null     null     
6     1     1     1     1     
7     1     1     1     1     
8     1     1     1     1     

===================================================
0
===================================================
0
===================================================
0
===================================================
0
