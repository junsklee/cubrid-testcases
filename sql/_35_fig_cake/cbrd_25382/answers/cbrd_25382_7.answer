===================================================
0
===================================================
0
===================================================
0
===================================================
4
===================================================
0
===================================================
0
===================================================
0
===================================================
0
===================================================
    
####  1. hint: recompile use_hash     

===================================================
a_ca    b_ca    c_ca    
1     1     1     
2     2     2     
3     3     3     
4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: flag[0]
seg[3]: [1]
seg[4]: ca[1] (f)
seg[5]: flag[1]
seg[6]: [2]
seg[7]: ca[2] (f)
seg[8]: flag[2]
Join graph nodes:
node[0]: dba.ta ab(ab)(4/1) (sargs 2) (loc 0)
node[1]: dba.tb b(ab)(4/1) (sargs 3) (loc 1)
node[2]: dba.tc c(4/1) (sargs 4) (loc 2)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2]
Join graph edges:
term[0]: (b.ca=c.ca) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: (ab.ca=b.ca) (ord 1) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[2]: ab.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[3]: b.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[4]: c.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
hash-join (inner join)
    edge:  term[0]
    outer: hash-join (inner join)
               edge:  term[1]
               outer: sscan
                          class: ab node[0]
                          sargs: term[2]
                          cost:  1 card 4
               inner: sscan
                          class: b node[1]
                          sargs: term[3]
                          cost:  1 card 4
               cost:  3 card 4
    inner: sscan
               class: c node[2]
               sargs: term[4]
               cost:  1 card 4
    cost:  4 card 4
Query stmt:
select /*+ USE_HASH */ ab.ca, b.ca, c.ca from ta ab, tb b, tc c where (b.ca=c.ca) and (ab.ca=b.ca) and b.flag= ?:0  and ab.flag= ?:1  and c.flag= ?:2 
===================================================
0
===================================================
    
####  2. hint: recompile + use_hash     

===================================================
a_ca    b_ca    c_ca    
1     1     1     
2     2     2     
3     3     3     
4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: flag[0]
seg[3]: [1]
seg[4]: ca[1] (f)
seg[5]: flag[1]
seg[6]: [2]
seg[7]: ca[2] (f)
seg[8]: flag[2]
Join graph nodes:
node[0]: dba.ta ab(ab)(4/1) (sargs 2) (loc 0)
node[1]: dba.tb b(ab)(4/1) (sargs 3) (loc 1)
node[2]: dba.tc c(4/1) (sargs 4) (loc 2)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2]
Join graph edges:
term[0]: (b.ca=c.ca) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: (ab.ca=b.ca) (ord 1) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[2]: ab.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[3]: b.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[4]: c.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
hash-join (inner join)
    edge:  term[0]
    outer: hash-join (inner join)
               edge:  term[1]
               outer: sscan
                          class: ab node[0]
                          sargs: term[2]
                          cost:  1 card 4
               inner: sscan
                          class: b node[1]
                          sargs: term[3]
                          cost:  1 card 4
               cost:  3 card 4
    inner: sscan
               class: c node[2]
               sargs: term[4]
               cost:  1 card 4
    cost:  4 card 4
Query stmt:
select /*+ USE_HASH */ ab.ca, b.ca, c.ca from ta ab, tb b, tc c where (b.ca=c.ca) and (ab.ca=b.ca) and b.flag= ?:0  and ab.flag= ?:1  and c.flag= ?:2 
===================================================
0
===================================================
    
####  3. hint: recompile use_hash + use_hash     

===================================================
a_ca    b_ca    c_ca    
1     1     1     
2     2     2     
3     3     3     
4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: flag[0]
seg[3]: [1]
seg[4]: ca[1] (f)
seg[5]: flag[1]
seg[6]: [2]
seg[7]: ca[2] (f)
seg[8]: flag[2]
Join graph nodes:
node[0]: dba.ta ab(ab)(4/1) (sargs 2) (loc 0)
node[1]: dba.tb b(ab)(4/1) (sargs 3) (loc 1)
node[2]: dba.tc c(4/1) (sargs 4) (loc 2)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2]
Join graph edges:
term[0]: (b.ca=c.ca) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: (ab.ca=b.ca) (ord 1) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[2]: ab.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[3]: b.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[4]: c.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
hash-join (inner join)
    edge:  term[0]
    outer: hash-join (inner join)
               edge:  term[1]
               outer: sscan
                          class: ab node[0]
                          sargs: term[2]
                          cost:  1 card 4
               inner: sscan
                          class: b node[1]
                          sargs: term[3]
                          cost:  1 card 4
               cost:  3 card 4
    inner: sscan
               class: c node[2]
               sargs: term[4]
               cost:  1 card 4
    cost:  4 card 4
Query stmt:
select /*+ USE_HASH */ ab.ca, b.ca, c.ca from ta ab, tb b, tc c where (b.ca=c.ca) and (ab.ca=b.ca) and b.flag= ?:0  and ab.flag= ?:1  and c.flag= ?:2 
===================================================
0
===================================================
    
####  4. hint: recompile no_use_hash + use_hash     

===================================================
a_ca    b_ca    c_ca    
1     1     1     
2     2     2     
3     3     3     
4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: flag[0]
seg[3]: [1]
seg[4]: ca[1] (f)
seg[5]: flag[1]
seg[6]: [2]
seg[7]: ca[2] (f)
seg[8]: flag[2]
Join graph nodes:
node[0]: dba.ta ab(ab)(4/1) (sargs 2) (loc 0)
node[1]: dba.tb b(ab)(4/1) (sargs 3) (loc 1)
node[2]: dba.tc c(4/1) (sargs 4) (loc 2)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2]
Join graph edges:
term[0]: (b.ca=c.ca) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: (ab.ca=b.ca) (ord 1) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[2]: ab.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[3]: b.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[4]: c.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
nl-join (inner join)
    edge:  term[0]
    outer: nl-join (inner join)
               edge:  term[1]
               outer: sscan
                          class: ab node[0]
                          sargs: term[2]
                          cost:  1 card 4
               inner: sscan
                          class: b node[1]
                          sargs: term[1] AND term[3]
                          cost:  1 card 4
               cost:  105 card 4
    inner: sscan
               class: c node[2]
               sargs: term[0] AND term[4]
               cost:  1 card 4
    cost:  209 card 4
Query stmt:
select /*+ NO_USE_HASH USE_HASH */ ab.ca, b.ca, c.ca from ta ab, tb b, tc c where (b.ca=c.ca) and (ab.ca=b.ca) and b.flag= ?:0  and ab.flag= ?:1  and c.flag= ?:2 
===================================================
0
===================================================
    
####  5. hint: recompile use_hash(ab,c) + use_hash(a,b)     

===================================================
a_ca    b_ca    c_ca    
1     1     1     
2     2     2     
3     3     3     
4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: flag[0]
seg[3]: [1]
seg[4]: ca[1] (f)
seg[5]: flag[1]
seg[6]: [2]
seg[7]: ca[2] (f)
seg[8]: flag[2]
Join graph nodes:
node[0]: dba.ta ab(ab)(4/1) (sargs 2) (loc 0)
node[1]: dba.tb b(ab)(4/1) (sargs 3) (loc 1)
node[2]: dba.tc c(4/1) (sargs 4) (loc 2)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2]
Join graph edges:
term[0]: (b.ca=c.ca) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: (ab.ca=b.ca) (ord 1) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[2]: ab.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[3]: b.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[4]: c.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
hash-join (inner join)
    edge:  term[0]
    outer: hash-join (inner join)
               edge:  term[1]
               outer: sscan
                          class: ab node[0]
                          sargs: term[2]
                          cost:  1 card 4
               inner: sscan
                          class: b node[1]
                          sargs: term[3]
                          cost:  1 card 4
               cost:  3 card 4
    inner: sscan
               class: c node[2]
               sargs: term[4]
               cost:  1 card 4
    cost:  4 card 4
Query stmt:
select /*+ USE_HASH(ab, c, a, b) */ ab.ca, b.ca, c.ca from ta ab, tb b, tc c where (b.ca=c.ca) and (ab.ca=b.ca) and b.flag= ?:0  and ab.flag= ?:1  and c.flag= ?:2 
===================================================
0
===================================================
    
####  6. hint: recompile use_hash(ab) + no_use_hash(a)     

===================================================
a_ca    b_ca    c_ca    
1     1     1     
2     2     2     
3     3     3     
4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: flag[0]
seg[3]: [1]
seg[4]: ca[1] (f)
seg[5]: flag[1]
seg[6]: [2]
seg[7]: ca[2] (f)
seg[8]: flag[2]
Join graph nodes:
node[0]: dba.ta ab(ab)(4/1) (sargs 2) (loc 0)
node[1]: dba.tb b(ab)(4/1) (sargs 3) (loc 1)
node[2]: dba.tc c(4/1) (sargs 4) (loc 2)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2]
Join graph edges:
term[0]: (b.ca=c.ca) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: (ab.ca=b.ca) (ord 1) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[2]: ab.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[3]: b.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[4]: c.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
nl-join (inner join)
    edge:  term[0]
    outer: nl-join (inner join)
               edge:  term[1]
               outer: sscan
                          class: ab node[0]
                          sargs: term[2]
                          cost:  1 card 4
               inner: sscan
                          class: b node[1]
                          sargs: term[1] AND term[3]
                          cost:  1 card 4
               cost:  105 card 4
    inner: sscan
               class: c node[2]
               sargs: term[0] AND term[4]
               cost:  1 card 4
    cost:  209 card 4
Query stmt:
select /*+ NO_USE_HASH(a) USE_HASH(ab) */ ab.ca, b.ca, c.ca from ta ab, tb b, tc c where (b.ca=c.ca) and (ab.ca=b.ca) and b.flag= ?:0  and ab.flag= ?:1  and c.flag= ?:2 
===================================================
0
===================================================
    
####  7. hint: recompile no_use_hash(ab) + use_hash(a)     

===================================================
a_ca    b_ca    c_ca    
1     1     1     
2     2     2     
3     3     3     
4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: flag[0]
seg[3]: [1]
seg[4]: ca[1] (f)
seg[5]: flag[1]
seg[6]: [2]
seg[7]: ca[2] (f)
seg[8]: flag[2]
Join graph nodes:
node[0]: dba.ta ab(ab)(4/1) (sargs 2) (loc 0)
node[1]: dba.tb b(ab)(4/1) (sargs 3) (loc 1)
node[2]: dba.tc c(4/1) (sargs 4) (loc 2)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2]
Join graph edges:
term[0]: (b.ca=c.ca) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: (ab.ca=b.ca) (ord 1) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[2]: ab.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[3]: b.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[4]: c.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
nl-join (inner join)
    edge:  term[0]
    outer: hash-join (inner join)
               edge:  term[1]
               outer: sscan
                          class: b node[1]
                          sargs: term[3]
                          cost:  1 card 4
               inner: sscan
                          class: ab node[0]
                          sargs: term[2]
                          cost:  1 card 4
               cost:  3 card 4
    inner: sscan
               class: c node[2]
               sargs: term[0] AND term[4]
               cost:  1 card 4
    cost:  107 card 4
Query stmt:
select /*+ NO_USE_HASH(ab) USE_HASH(a) */ ab.ca, b.ca, c.ca from ta ab, tb b, tc c where (b.ca=c.ca) and (ab.ca=b.ca) and b.flag= ?:0  and ab.flag= ?:1  and c.flag= ?:2 
===================================================
0
===================================================
    
####  8. hint: recompile no_use_hash(a,b,c) + use_hash(a,b,c)     

===================================================
a_ca    b_ca    c_ca    
1     1     1     
2     2     2     
3     3     3     
4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: flag[0]
seg[3]: [1]
seg[4]: ca[1] (f)
seg[5]: flag[1]
seg[6]: [2]
seg[7]: ca[2] (f)
seg[8]: flag[2]
Join graph nodes:
node[0]: dba.ta ab(ab)(4/1) (sargs 2) (loc 0)
node[1]: dba.tb b(ab)(4/1) (sargs 3) (loc 1)
node[2]: dba.tc c(4/1) (sargs 4) (loc 2)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2]
Join graph edges:
term[0]: (b.ca=c.ca) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: (ab.ca=b.ca) (ord 1) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[2]: ab.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[3]: b.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[4]: c.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
hash-join (inner join)
    edge:  term[1]
    outer: hash-join (inner join)
               edge:  term[0]
               outer: sscan
                          class: c node[2]
                          sargs: term[4]
                          cost:  1 card 4
               inner: sscan
                          class: b node[1]
                          sargs: term[3]
                          cost:  1 card 4
               cost:  3 card 4
    inner: sscan
               class: ab node[0]
               sargs: term[2]
               cost:  1 card 4
    cost:  4 card 4
Query stmt:
select /*+ NO_USE_HASH(c) USE_HASH(a, b) */ ab.ca, b.ca, c.ca from ta ab, tb b, tc c where (b.ca=c.ca) and (ab.ca=b.ca) and b.flag= ?:0  and ab.flag= ?:1  and c.flag= ?:2 
===================================================
0
===================================================
    
####  9. hint: recompile use_hash(a,b,c) + no_use_hash(a,b,c)     

===================================================
a_ca    b_ca    c_ca    
1     1     1     
2     2     2     
3     3     3     
4     4     4     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: flag[0]
seg[3]: [1]
seg[4]: ca[1] (f)
seg[5]: flag[1]
seg[6]: [2]
seg[7]: ca[2] (f)
seg[8]: flag[2]
Join graph nodes:
node[0]: dba.ta ab(ab)(4/1) (sargs 2) (loc 0)
node[1]: dba.tb b(ab)(4/1) (sargs 3) (loc 1)
node[2]: dba.tc c(4/1) (sargs 4) (loc 2)
Join graph equivalence classes:
eqclass[0]: ca[0] ca[1] ca[2]
Join graph edges:
term[0]: (b.ca=c.ca) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: (ab.ca=b.ca) (ord 1) (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Join graph terms:
term[2]: ab.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[3]: b.flag=1 (ord 1) (sel 1) (sarg term) (not-join eligible) (loc 0)
term[4]: c.flag=1 (sel 1) (sarg term) (not-join eligible) (loc 0)
Query plan:
hash-join (inner join)
    edge:  term[0]
    outer: nl-join (inner join)
               edge:  term[1]
               outer: sscan
                          class: ab node[0]
                          sargs: term[2]
                          cost:  1 card 4
               inner: sscan
                          class: b node[1]
                          sargs: term[1] AND term[3]
                          cost:  1 card 4
               cost:  105 card 4
    inner: sscan
               class: c node[2]
               sargs: term[4]
               cost:  1 card 4
    cost:  107 card 4
Query stmt:
select /*+ NO_USE_HASH(a, b) USE_HASH(c) */ ab.ca, b.ca, c.ca from ta ab, tb b, tc c where (b.ca=c.ca) and (ab.ca=b.ca) and b.flag= ?:0  and ab.flag= ?:1  and c.flag= ?:2 
===================================================
0
===================================================
0
