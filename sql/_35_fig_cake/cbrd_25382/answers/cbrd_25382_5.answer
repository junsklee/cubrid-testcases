===================================================
0
===================================================
0
===================================================
0
===================================================
0
===================================================
0
===================================================
0
===================================================
2000
===================================================
2000
===================================================
2000
===================================================
2000
===================================================
0
===================================================
0
===================================================
0
===================================================
    
####  1. empty outer     

===================================================
a_cd    b_cd    

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: cd[0] (f)
seg[2]: ca[0]
seg[3]: [1]
seg[4]: cd[1] (f)
Join graph nodes:
node[0]: dba.ta a(2000/6) (sargs 1) (loc 0)
node[1]: dba.tb b(2000/6) (outer-dep-set 0) (loc 1)
Join graph equivalence classes:
eqclass[0]: cd[0] cd[1]
Join graph edges:
term[0]: a.cd=b.cd (sel ?) (join term) (mergeable) (inner-join) (indexable cd[0] cd[1]) (loc 0)
Join graph terms:
term[1]: a.ca=-1 (sel ?) (sarg term) (not-join eligible) (indexable ca[0]) (loc 0)
Query plan:
temp(order by)
    subplan: hash-join (inner join)
                 edge:  term[0]
                 outer: iscan
                            class: a node[0]
                            index: i1 term[1]
                            cost:  14 card 200
                 inner: sscan
                            class: b node[1]
                            cost:  11 card 2000
                 cost:  140 card 200
    sort:  1 asc
    cost:  146 card 200
Query stmt:
select /*+ ORDERED USE_HASH */ a.cd, b.cd from ta a, tb b where a.cd=b.cd and a.ca= ?:0  order by 1
===================================================
trace    

Query Plan:
  SORT (order by)
    HASH JOIN (inner join)
      INDEX SCAN (a.i?) (key range: a.ca= ?:? )
      TABLE SCAN (b)

  rewritten query: select /*+ ORDERED USE_HASH */ a.cd, b.cd from [dba.ta] a, [dba.tb] b where a.cd=b.cd and a.ca= ?:?  order by ?

Trace Statistics:
  SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
    SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
      HASHJOIN (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        BUILD (time: ?, build_time: ?, fetch: ?, fetch_time: ?, ioread: ?, hash_method: skip)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (table: dba.tb), (noscan time: ?, fetch: ?, ioread: ?)
        PROBE (time: ?, probe_time: ?, fetch: ?, fetch_time: ?, ioread: ?, readkeys: ?, rows: ?, max_collisions: ?)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (index: dba.ta.i?), (btree time: ?, fetch: ?, ioread: ?, readkeys: ?, filteredkeys: ?, rows: ?) (lookup time: ?, rows: ?)
     

===================================================
0
===================================================
    
####  2. empty inner     

===================================================
a_cd    b_cd    

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: cd[0] (f)
seg[2]: [1]
seg[3]: cd[1] (f)
seg[4]: ca[1]
Join graph nodes:
node[0]: dba.ta a(2000/6) (loc 0)
node[1]: dba.tb b(2000/6) (sargs 1) (outer-dep-set 0) (loc 1)
Join graph equivalence classes:
eqclass[0]: cd[0] cd[1]
Join graph edges:
term[0]: a.cd=b.cd (sel ?) (join term) (mergeable) (inner-join) (indexable cd[0] cd[1]) (loc 0)
Join graph terms:
term[1]: b.ca=-1 (sel ?) (sarg term) (not-join eligible) (indexable ca[1]) (loc 0)
Query plan:
temp(order by)
    subplan: hash-join (inner join)
                 edge:  term[0]
                 outer: sscan
                            class: a node[0]
                            cost:  11 card 2000
                 inner: iscan
                            class: b node[1]
                            index: i1 term[1]
                            cost:  14 card 200
                 cost:  140 card 200
    sort:  1 asc
    cost:  146 card 200
Query stmt:
select /*+ ORDERED USE_HASH */ a.cd, b.cd from ta a, tb b where a.cd=b.cd and b.ca= ?:0  order by 1
===================================================
trace    

Query Plan:
  SORT (order by)
    HASH JOIN (inner join)
      TABLE SCAN (a)
      INDEX SCAN (b.i?) (key range: b.ca= ?:? )

  rewritten query: select /*+ ORDERED USE_HASH */ a.cd, b.cd from [dba.ta] a, [dba.tb] b where a.cd=b.cd and b.ca= ?:?  order by ?

Trace Statistics:
  SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
    SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
      HASHJOIN (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        BUILD (time: ?, build_time: ?, fetch: ?, fetch_time: ?, ioread: ?, hash_method: skip)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (index: dba.tb.i?), (btree time: ?, fetch: ?, ioread: ?, readkeys: ?, filteredkeys: ?, rows: ?) (lookup time: ?, rows: ?)
        PROBE (time: ?, probe_time: ?, fetch: ?, fetch_time: ?, ioread: ?, readkeys: ?, rows: ?, max_collisions: ?)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (table: dba.ta), (heap time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
     

===================================================
0
===================================================
    
####  3. empty inner + left outer join     

===================================================
a_cd    b_cd    
2000     null     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: cd[0] (f)
seg[2]: [1]
seg[3]: cd[1] (f)
seg[4]: ca[1]
Join graph nodes:
node[0]: dba.ta a(2000/6) (loc 0)
node[1]: dba.tb b(2000/6) (sargs 1) (outer-dep-set 0) (loc 1)
Join graph equivalence classes:
eqclass[0]: cd[0] cd[1]
Join graph edges:
term[0]: b.cd=a.cd (sel ?) (join term) (mergeable) (left-join) (indexable cd[1] cd[0]) (loc 1)
Join graph terms:
term[1]: b.ca=-1 (sel ?) (sarg term) (not-join eligible) (indexable ca[1]) (loc 1)
Query plan:
temp(order by)
    subplan: hash-join (left outer join)
                 edge:  term[0]
                 outer: sscan
                            class: a node[0]
                            cost:  11 card 2000
                 inner: iscan
                            class: b node[1]
                            index: i1 term[1]
                            cost:  14 card 200
                 cost:  140 card 2000
    sort:  1 asc
    cost:  152 card 2000
Query stmt:
select /*+ ORDERED USE_HASH */ a.cd, b.cd from ta a left outer join tb b on b.ca= ?:0  and b.cd=a.cd order by 1 for orderby_num()> ?:1  and orderby_num()<= ?:2 
===================================================
trace    

Query Plan:
  SORT (order by)
    HASH JOIN (left outer join)
      TABLE SCAN (a)
      INDEX SCAN (b.i?) (key range: b.ca= ?:? )

  rewritten query: select /*+ ORDERED USE_HASH */ a.cd, b.cd from [dba.ta] a left outer join [dba.tb] b on b.ca= ?:?  and b.cd=a.cd order by ? for orderby_num()> ?:?  and orderby_num()<= ?:? 

Trace Statistics:
  SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
    SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
    ORDERBY (time: ?, topnsort: true)
      HASHJOIN (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        BUILD (time: ?, build_time: ?, fetch: ?, fetch_time: ?, ioread: ?, hash_method: skip)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (index: dba.tb.i?), (btree time: ?, fetch: ?, ioread: ?, readkeys: ?, filteredkeys: ?, rows: ?) (lookup time: ?, rows: ?)
        PROBE (time: ?, probe_time: ?, fetch: ?, fetch_time: ?, ioread: ?, readkeys: ?, rows: ?, max_collisions: ?)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (table: dba.ta), (heap time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
     

===================================================
0
===================================================
    
####  4. multiple tables     

===================================================
a_cd    b_cd    c_cd    d_cd    
1     1     1     1     
1001     1001     1001     1001     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: cd[0] (f)
seg[2]: cc[0]
seg[3]: [1]
seg[4]: cd[1] (f)
seg[5]: cc[1]
seg[6]: [2]
seg[7]: cd[2] (f)
seg[8]: cc[2]
seg[9]: [3]
seg[10]: cd[3] (f)
seg[11]: cc[3]
Join graph nodes:
node[0]: dba.ta a(2000/6) (sargs 5) (loc 0)
node[1]: dba.tb b(2000/6) (sargs 4) (loc 1)
node[2]: dba.tc c(2000/6) (sargs 3) (loc 2)
node[3]: dba.td d(2000/6) (sargs 6) (loc 3)
Join graph equivalence classes:
eqclass[0]: cd[0] cd[1] cd[2] cd[3]
Join graph edges:
term[0]: a.cd=b.cd (sel ?) (join term) (mergeable) (inner-join) (indexable cd[0] cd[1]) (loc 0)
term[1]: b.cd=c.cd (sel ?) (join term) (mergeable) (inner-join) (indexable cd[1] cd[2]) (loc 0)
term[2]: c.cd=d.cd (sel ?) (join term) (mergeable) (inner-join) (indexable cd[2] cd[3]) (loc 0)
Join graph terms:
term[3]: c.cc=1 (sel ?) (sarg term) (not-join eligible) (indexable cc[2]) (loc 0)
term[4]: b.cc=1 (sel ?) (sarg term) (not-join eligible) (indexable cc[1]) (loc 0)
term[5]: a.cc=1 (sel ?) (sarg term) (not-join eligible) (indexable cc[0]) (loc 0)
term[6]: d.cc=1 (sel ?) (sarg term) (not-join eligible) (indexable cc[3]) (loc 0)
Query plan:
temp(order by)
    subplan: hash-join (inner join)
                 edge:  term[2]
                 outer: hash-join (inner join)
                            edge:  term[1]
                            outer: hash-join (inner join)
                                       edge:  term[0]
                                       outer: sscan
                                                  class: a node[0]
                                                  sargs: term[5]
                                                  cost:  11 card 2
                                       inner: sscan
                                                  class: b node[1]
                                                  sargs: term[4]
                                                  cost:  11 card 2
                                       cost:  22 card 1
                            inner: sscan
                                       class: c node[2]
                                       sargs: term[3]
                                       cost:  11 card 2
                            cost:  33 card 1
                 inner: sscan
                            class: d node[3]
                            sargs: term[6]
                            cost:  11 card 2
                 cost:  45 card 1
    sort:  1 asc
    cost:  51 card 1
Query stmt:
select /*+ USE_HASH */ a.cd, b.cd, c.cd, d.cd from ta a, tb b, tc c, td d where a.cd=b.cd and b.cd=c.cd and c.cd=d.cd and d.cc= ?:0  and c.cc= ?:1  and b.cc= ?:2  and a.cc= ?:3  order by 1
===================================================
trace    

Query Plan:
  SORT (order by)
    HASH JOIN (inner join)
      HASH JOIN (inner join)
        HASH JOIN (inner join)
          TABLE SCAN (a)
          TABLE SCAN (b)
        TABLE SCAN (c)
      TABLE SCAN (d)

  rewritten query: select /*+ USE_HASH */ a.cd, b.cd, c.cd, d.cd from [dba.ta] a, [dba.tb] b, [dba.tc] c, [dba.td] d where a.cd=b.cd and b.cd=c.cd and c.cd=d.cd and d.cc= ?:?  and c.cc= ?:?  and b.cc= ?:?  and a.cc= ?:?  order by ?

Trace Statistics:
  SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
    SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
    ORDERBY (time: ?, sort: true, page: ?, ioread: ?)
      HASHJOIN (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        BUILD (time: ?, build_time: ?, fetch: ?, fetch_time: ?, ioread: ?, hash_method: memory)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (table: dba.td), (heap time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
        PROBE (time: ?, probe_time: ?, fetch: ?, fetch_time: ?, ioread: ?, readkeys: ?, rows: ?, max_collisions: ?)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
              HASHJOIN (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
                BUILD (time: ?, build_time: ?, fetch: ?, fetch_time: ?, ioread: ?, hash_method: memory)
                  SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
                    SCAN (table: dba.tc), (heap time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
                PROBE (time: ?, probe_time: ?, fetch: ?, fetch_time: ?, ioread: ?, readkeys: ?, rows: ?, max_collisions: ?)
                  SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
                    SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
                      HASHJOIN (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
                        BUILD (time: ?, build_time: ?, fetch: ?, fetch_time: ?, ioread: ?, hash_method: memory)
                          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
                            SCAN (table: dba.tb), (heap time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
                        PROBE (time: ?, probe_time: ?, fetch: ?, fetch_time: ?, ioread: ?, readkeys: ?, rows: ?, max_collisions: ?)
                          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
                            SCAN (table: dba.ta), (heap time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
     

===================================================
0
===================================================
    
####  5. inline views     

===================================================
a_cd    b_cd    
2     2     
1002     1002     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: cb[0] (f)
seg[3]: cc[0] (f)
seg[4]: cd[0] (f)
Join graph nodes:
node[0]: dba.ta dba.ta(2000/6) (sargs 0) (loc 0)
Join graph terms:
term[0]: [dba.ta].cc=2 (sel ?) (sarg term) (not-join eligible) (indexable cc[0]) (loc 0)
Query plan:
sscan
    class: ta node[0]
    sargs: term[0]
    cost:  11 card 2
Query stmt:
(select /*+ NO_MERGE */ ta.ca, ta.cb, ta.cc, ta.cd from ta ta where ta.cc= ?:0 )
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: cb[0] (f)
seg[3]: cc[0] (f)
seg[4]: cd[0] (f)
Join graph nodes:
node[0]: dba.tb dba.tb(2000/6) (sargs 0) (loc 0)
Join graph terms:
term[0]: [dba.tb].cc=2 (sel ?) (sarg term) (not-join eligible) (indexable cc[0]) (loc 0)
Query plan:
sscan
    class: tb node[0]
    sargs: term[0]
    cost:  11 card 2
Query stmt:
(select /*+ NO_MERGE */ tb.ca, tb.cb, tb.cc, tb.cd from tb tb where tb.cc= ?:1 )
Join graph segments (f indicates final):
seg[0]: ca[0]
seg[1]: cb[0]
seg[2]: cc[0]
seg[3]: cd[0] (f)
seg[4]: ca[1]
seg[5]: cb[1]
seg[6]: cc[1]
seg[7]: cd[1] (f)
Join graph nodes:
node[0]: a(2/1) (loc 0)
node[1]: b(2/1) (loc 1)
Join graph equivalence classes:
eqclass[0]: cd[0] cd[1]
Join graph edges:
term[0]: a.cd=b.cd (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: hash-join (inner join)
                 edge:  term[0]
                 outer: sscan
                            class: a node[0]
                            cost:  1 card 2
                 inner: sscan
                            class: b node[1]
                            cost:  1 card 2
                 cost:  2 card 1
    sort:  1 asc
    cost:  8 card 1
Query stmt:
select /*+ USE_HASH */ a.cd, b.cd from (select /*+ NO_MERGE */ ta.ca, ta.cb, ta.cc, ta.cd from ta ta where ta.cc= ?:0 ) a (ca, cb, cc, cd), (select /*+ NO_MERGE */ tb.ca, tb.cb, tb.cc, tb.cd from tb tb where tb.cc= ?:1 ) b (ca, cb, cc, cd) where a.cd=b.cd order by 1
===================================================
trace    

Query Plan:
  TABLE SCAN (dba.ta)

  rewritten query: (select /*+ NO_MERGE */ [dba.ta].ca, [dba.ta].cb, [dba.ta].cc, [dba.ta].cd from [dba.ta] [dba.ta] where [dba.ta].cc= ?:? )

  TABLE SCAN (dba.tb)

  rewritten query: (select /*+ NO_MERGE */ [dba.tb].ca, [dba.tb].cb, [dba.tb].cc, [dba.tb].cd from [dba.tb] [dba.tb] where [dba.tb].cc= ?:? )

  SORT (order by)
    HASH JOIN (inner join)
      TABLE SCAN (a)
      TABLE SCAN (b)

  rewritten query: select /*+ USE_HASH */ a.cd, b.cd from (select /*+ NO_MERGE */ [dba.ta].ca, [dba.ta].cb, [dba.ta].cc, [dba.ta].cd from [dba.ta] [dba.ta] where [dba.ta].cc= ?:? ) a (ca, cb, cc, cd), (select /*+ NO_MERGE */ [dba.tb].ca, [dba.tb].cb, [dba.tb].cc, [dba.tb].cd from [dba.tb] [dba.tb] where [dba.tb].cc= ?:? ) b (ca, cb, cc, cd) where a.cd=b.cd order by ?


Trace Statistics:
  SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
    SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
    ORDERBY (time: ?, sort: true, page: ?, ioread: ?)
    SUBQUERY (uncorrelated)
      SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        SCAN (table: dba.ta), (heap time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
      SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        SCAN (table: dba.tb), (heap time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
      HASHJOIN (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        BUILD (time: ?, build_time: ?, fetch: ?, fetch_time: ?, ioread: ?, hash_method: memory)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
        PROBE (time: ?, probe_time: ?, fetch: ?, fetch_time: ?, ioread: ?, readkeys: ?, rows: ?, max_collisions: ?)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
     

===================================================
0
===================================================
    
####  6. subqueries     

===================================================
a_cd    b_cd    d_cd    
3     3     3     
1003     1003     1003     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: cd[0] (f)
Join graph nodes:
node[0]: dba.td d(2000/6) (sargs 0 1) (loc 0)
Join graph terms:
term[0]: d.cd=b.cd (sel ?) (sarg term) (not-join eligible) (indexable cd[0]) (loc 0)
term[1]: d.cd=b.cd (sel ?) (sarg term) (not-join eligible) (indexable cd[0]) (loc 0)
Query plan:
iscan
    class: d node[0]
    index: i3 term[0] (covers)
    filtr: term[1]
    cost:  3 card 1
Query stmt:
(select /*+ NO_SUBQUERY_CACHE */ d.cd from td d where d.cd=b.cd and d.cd=b.cd)
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: cb[0] (f)
seg[3]: cc[0] (f)
seg[4]: cd[0] (f)
Join graph nodes:
node[0]: dba.ta dba.ta(2000/6) (sargs 0) (loc 0)
Join graph terms:
term[0]: [dba.ta].cc=3 (sel ?) (sarg term) (not-join eligible) (indexable cc[0]) (loc 0)
Query plan:
sscan
    class: ta node[0]
    sargs: term[0]
    cost:  11 card 2
Query stmt:
(select /*+ NO_MERGE */ ta.ca, ta.cb, ta.cc, ta.cd from ta ta where ta.cc= ?:0 )
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: cb[0] (f)
seg[3]: cc[0] (f)
seg[4]: cd[0] (f)
Join graph nodes:
node[0]: dba.tb dba.tb(2000/6) (sargs 0) (loc 0)
Join graph terms:
term[0]: [dba.tb].cc=3 (sel ?) (sarg term) (not-join eligible) (indexable cc[0]) (loc 0)
Query plan:
sscan
    class: tb node[0]
    sargs: term[0]
    cost:  11 card 2
Query stmt:
(select /*+ NO_MERGE */ tb.ca, tb.cb, tb.cc, tb.cd from tb tb where tb.cc= ?:1 )
Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
Join graph nodes:
node[0]: dba.tc c(2000/6) (loc 0)
Query plan:
temp(distinct)
    subplan: sscan
                 class: c node[0]
                 cost:  11 card 2000
    cost:  23 card 2000
Query stmt:
(select distinct c.ca from tc c)
Join graph segments (f indicates final):
seg[0]: ca[0]
seg[1]: cb[0]
seg[2]: cc[0]
seg[3]: cd[0] (f)
seg[4]: ca[1]
seg[5]: cb[1]
seg[6]: cc[1]
seg[7]: cd[1] (f)
seg[8]: av_1[2]
Join graph nodes:
node[0]: a(2/1) (loc 0)
node[1]: b(2/1) (loc 1)
node[2]: av1861(2000/1) (loc -1)
Join graph equivalence classes:
eqclass[0]: ca[0] av_1[2]
eqclass[1]: cd[0] cd[1]
Join graph edges:
term[0]: a.cd=b.cd (sel ?) (join term) (mergeable) (inner-join) (loc 0)
term[1]: a.ca=av1861.av_1 (sel ?) (join term) (mergeable) (inner-join) (loc 0)
Query plan:
temp(order by)
    subplan: hash-join (inner join)
                 edge:  term[1]
                 outer: hash-join (inner join)
                            edge:  term[0]
                            outer: sscan
                                       class: a node[0]
                                       cost:  1 card 2
                            inner: sscan
                                       class: b node[1]
                                       cost:  1 card 2
                            cost:  2 card 1
                 inner: sscan
                            class: av1861 node[2]
                            cost:  6 card 2000
                 cost:  108 card 2
    sort:  1 asc
    cost:  114 card 2
Query stmt:
select /*+ USE_HASH */ a.cd, b.cd, (select /*+ NO_SUBQUERY_CACHE */ d.cd from td d where d.cd=b.cd and d.cd=b.cd) from (select /*+ NO_MERGE */ ta.ca, ta.cb, ta.cc, ta.cd from ta ta where ta.cc= ?:0 ) a (ca, cb, cc, cd), (select /*+ NO_MERGE */ tb.ca, tb.cb, tb.cc, tb.cd from tb tb where tb.cc= ?:1 ) b (ca, cb, cc, cd), (select distinct c.ca from tc c) av1861 (av_1) where a.cd=b.cd and a.ca=av1861.av_1 order by 1
===================================================
trace    

Query Plan:
  INDEX SCAN (d.i?) (key range: d.cd=b.cd, key filter: d.cd=b.cd, covered: true)

  rewritten query: (select /*+ NO_SUBQUERY_CACHE */ d.cd from [dba.td] d where d.cd=b.cd and d.cd=b.cd)

  TABLE SCAN (dba.ta)

  rewritten query: (select /*+ NO_MERGE */ [dba.ta].ca, [dba.ta].cb, [dba.ta].cc, [dba.ta].cd from [dba.ta] [dba.ta] where [dba.ta].cc= ?:? )

  TABLE SCAN (dba.tb)

  rewritten query: (select /*+ NO_MERGE */ [dba.tb].ca, [dba.tb].cb, [dba.tb].cc, [dba.tb].cd from [dba.tb] [dba.tb] where [dba.tb].cc= ?:? )

  SORT (distinct)
    TABLE SCAN (c)

  rewritten query: (select distinct c.ca from [dba.tc] c)

  SORT (order by)
    HASH JOIN (inner join)
      HASH JOIN (inner join)
        TABLE SCAN (a)
        TABLE SCAN (b)
      TABLE SCAN (av?)

  rewritten query: select /*+ USE_HASH */ a.cd, b.cd, (select /*+ NO_SUBQUERY_CACHE */ d.cd from [dba.td] d where d.cd=b.cd and d.cd=b.cd) from (select /*+ NO_MERGE */ [dba.ta].ca, [dba.ta].cb, [dba.ta].cc, [dba.ta].cd from [dba.ta] [dba.ta] where [dba.ta].cc= ?:? ) a (ca, cb, cc, cd), (select /*+ NO_MERGE */ [dba.tb].ca, [dba.tb].cb, [dba.tb].cc, [dba.tb].cd from [dba.tb] [dba.tb] where [dba.tb].cc= ?:? ) b (ca, cb, cc, cd), (select distinct c.ca from [dba.tc] c) av? (av_?) where a.cd=b.cd and a.ca=av?.av_? order by ?


Trace Statistics:
  SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
    SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
    ORDERBY (time: ?, sort: true, page: ?, ioread: ?)
    SUBQUERY (uncorrelated)
      SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        SCAN (table: dba.ta), (heap time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
      SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        SCAN (table: dba.tb), (heap time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
      SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        SCAN (table: dba.tc), (heap time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
        ORDERBY (time: ?, sort: true, page: ?, ioread: ?)
      HASHJOIN (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        BUILD (time: ?, build_time: ?, fetch: ?, fetch_time: ?, ioread: ?, hash_method: memory)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
              HASHJOIN (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
                BUILD (time: ?, build_time: ?, fetch: ?, fetch_time: ?, ioread: ?, hash_method: memory)
                  SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
                    SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
                PROBE (time: ?, probe_time: ?, fetch: ?, fetch_time: ?, ioread: ?, readkeys: ?, rows: ?, max_collisions: ?)
                  SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
                    SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
        PROBE (time: ?, probe_time: ?, fetch: ?, fetch_time: ?, ioread: ?, readkeys: ?, rows: ?, max_collisions: ?)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
    SUBQUERY (correlated)
      SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        SCAN (index: dba.td.i?), (btree time: ?, fetch: ?, ioread: ?, readkeys: ?, filteredkeys: ?, rows: ?, covered: true)
     

===================================================
0
===================================================
    
####  7. ctes (common table expressions)     

===================================================
c_cd    d_cd    
4     4     
1004     1004     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: ca[0] (f)
seg[2]: cb[0] (f)
seg[3]: cc[0] (f)
seg[4]: cd[0] (f)
seg[5]: [1]
seg[6]: cd[1]
seg[7]: ca[1]
Join graph nodes:
node[0]: dba.ta a(2000/6) (sargs 1) (loc 0)
node[1]: dba.tb b(2000/6) (sargs 2) (loc 1)
Join graph equivalence classes:
eqclass[0]: cd[0] cd[1]
Join graph edges:
term[0]: a.cd=b.cd (sel ?) (join term) (mergeable) (inner-join) (indexable cd[0] cd[1]) (loc 0)
Join graph terms:
term[1]: a.ca=4 (sel ?) (sarg term) (not-join eligible) (indexable ca[0]) (loc 0)
term[2]: b.ca=4 (sel ?) (sarg term) (not-join eligible) (indexable ca[1]) (loc 0)
Query plan:
hash-join (inner join)
    edge:  term[0]
    outer: iscan
               class: a node[0]
               index: i1 term[1]
               cost:  14 card 200
    inner: iscan
               class: b node[1]
               index: i1 term[2]
               cost:  14 card 200
    cost:  52 card 20
Query stmt:
select /*+ USE_HASH */ a.ca, a.cb, a.cc, a.cd from ta a, tb b where a.cd=b.cd and b.ca= ?:2  and a.ca= ?:3 
Join graph segments (f indicates final):
seg[0]: ca[0]
seg[1]: cb[0]
seg[2]: cc[0]
seg[3]: cd[0] (f)
seg[4]: [1]
seg[5]: cd[1] (f)
seg[6]: cc[1]
Join graph nodes:
node[0]: c(5/1) (sargs 1) (loc 0)
node[1]: dba.td d(2000/6) (sargs 2) (loc 1)
Join graph equivalence classes:
eqclass[0]: cd[0] cd[1]
Join graph edges:
term[0]: c.cd=d.cd (sel ?) (join term) (mergeable) (inner-join) (indexable cd[1]) (loc 0)
Join graph terms:
term[1]: c.cc=4 (sel ?) (sarg term) (not-join eligible) (loc 0)
term[2]: d.cc=4 (sel ?) (sarg term) (not-join eligible) (indexable cc[1]) (loc 0)
Query plan:
temp(order by)
    subplan: hash-join (inner join)
                 edge:  term[0]
                 outer: sscan
                            simple CTE:c node[0]
                            sargs: term[1]
                            cost:  1 card 1
                 inner: sscan
                            class: d node[1]
                            sargs: term[2]
                            cost:  11 card 2
                 cost:  12 card 1
    sort:  1 asc
    cost:  18 card 1
Query stmt:
with cte(ca, cb, cc, cd) as (select /*+ USE_HASH */ a.ca, a.cb, a.cc, a.cd from ta a, tb b where a.cd=b.cd and b.ca= ?:2  and a.ca= ?:3 )select /*+ USE_HASH */ c.cd, d.cd from cte c, td d where c.cd=d.cd and d.cc= ?:0  and c.cc= ?:1  order by 1
===================================================
trace    

Query Plan:
  HASH JOIN (inner join)
    INDEX SCAN (a.i?) (key range: a.ca= ?:? )
    INDEX SCAN (b.i?) (key range: b.ca= ?:? )

  rewritten query: select /*+ USE_HASH */ a.ca, a.cb, a.cc, a.cd from [dba.ta] a, [dba.tb] b where a.cd=b.cd and b.ca= ?:?  and a.ca= ?:? 

  SORT (order by)
    HASH JOIN (inner join)
      TABLE SCAN (c)
      TABLE SCAN (d)

  rewritten query: with cte(ca, cb, cc, cd) as (select /*+ USE_HASH */ a.ca, a.cb, a.cc, a.cd from [dba.ta] a, [dba.tb] b where a.cd=b.cd and b.ca= ?:?  and a.ca= ?:? )select /*+ USE_HASH */ c.cd, d.cd from [dba.cte] c, [dba.td] d where c.cd=d.cd and d.cc= ?:?  and c.cc= ?:?  order by ?


Trace Statistics:
  SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
    SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
    ORDERBY (time: ?, sort: true, page: ?, ioread: ?)
    SUBQUERY (uncorrelated)
      CTE (non_recursive_part)
        SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
          SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
            HASHJOIN (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
              BUILD (time: ?, build_time: ?, fetch: ?, fetch_time: ?, ioread: ?, hash_method: memory)
                SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
                  SCAN (index: dba.tb.i?), (btree time: ?, fetch: ?, ioread: ?, readkeys: ?, filteredkeys: ?, rows: ?) (lookup time: ?, rows: ?)
              PROBE (time: ?, probe_time: ?, fetch: ?, fetch_time: ?, ioread: ?, readkeys: ?, rows: ?, max_collisions: ?)
                SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
                  SCAN (index: dba.ta.i?), (btree time: ?, fetch: ?, ioread: ?, readkeys: ?, filteredkeys: ?, rows: ?) (lookup time: ?, rows: ?)
      HASHJOIN (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
        BUILD (time: ?, build_time: ?, fetch: ?, fetch_time: ?, ioread: ?, hash_method: memory)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (table: dba.td), (heap time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
        PROBE (time: ?, probe_time: ?, fetch: ?, fetch_time: ?, ioread: ?, readkeys: ?, rows: ?, max_collisions: ?)
          SELECT (time: ?, fetch: ?, fetch_time: ?, ioread: ?)
            SCAN (temp time: ?, fetch: ?, ioread: ?, readrows: ?, rows: ?)
     

===================================================
0
===================================================
    
####  8. json format output     

===================================================
0
===================================================
a_cd    b_cd    
5     5     
1005     1005     

Join graph segments (f indicates final):
seg[0]: [0]
seg[1]: cd[0] (f)
seg[2]: cc[0]
seg[3]: [1]
seg[4]: cd[1] (f)
seg[5]: cc[1]
Join graph nodes:
node[0]: dba.ta a(2000/6) (sargs 1) (loc 0)
node[1]: dba.tb b(2000/6) (sargs 2) (loc 1)
Join graph equivalence classes:
eqclass[0]: cd[0] cd[1]
Join graph edges:
term[0]: a.cd=b.cd (sel ?) (join term) (mergeable) (inner-join) (indexable cd[0] cd[1]) (loc 0)
Join graph terms:
term[1]: a.cc=5 (sel ?) (sarg term) (not-join eligible) (indexable cc[0]) (loc 0)
term[2]: b.cc=5 (sel ?) (sarg term) (not-join eligible) (indexable cc[1]) (loc 0)
Query plan:
temp(order by)
    subplan: hash-join (inner join)
                 edge:  term[0]
                 outer: sscan
                            class: a node[0]
                            sargs: term[1]
                            cost:  11 card 2
                 inner: sscan
                            class: b node[1]
                            sargs: term[2]
                            cost:  11 card 2
                 cost:  22 card 1
    sort:  1 asc
    cost:  28 card 1
Query stmt:
select /*+ USE_HASH */ a.cd, b.cd from ta a, tb b where a.cd=b.cd and b.cc= ?:0  and a.cc= ?:1  order by 1
===================================================
trace    
{
  "Query Plan": {
    "SORT (order by)": {
      "HASH JOIN (inner join)": [
        {
          "TABLE SCAN": {
            "table": "a"
          }
        },
        {
          "TABLE SCAN": {
            "table": "b"
          }
        }
      ]
    },
    "rewritten query": "select /*+ USE_HASH */ a.cd, b.cd from [dba.ta] a, [dba.tb] b where a.cd=b.cd and b.cc= ?:?  and a.cc= ?:?  order by ?"
  },
  "Trace Statistics": {
    "SELECT": {
      "time": ?,
      "fetch": ?,
      "fetch_time": ?,
      "ioread": ?,
      "SCAN": {
        "access": "temp",
        "temp": {
          "time": ?,
          "fetch": ?,
          "ioread": ?,
          "readrows": ?,
          "rows": ?
        }
      },
      "ORDERBY": {
        "time": ?,
        "sort": true,
        "page": ?,
        "ioread": ?
      },
      "SUBQUERY (uncorrelated)": [
        {
          "HASHJOIN": {
            "time": ?,
            "fetch": ?,
            "fetch_time": ?,
            "ioread": ?,
            "build": {
              "time": ?,
              "build_time": ?,
              "fetch": ?,
              "fetch_time": ?,
              "ioread": ?,
              "hash_method": "memory",
              "input": {
                "SELECT": {
                  "time": ?,
                  "fetch": ?,
                  "fetch_time": ?,
                  "ioread": ?,
                  "SCAN": {
                    "access": "table (dba.tb)",
                    "heap": {
                      "time": ?,
                      "fetch": ?,
                      "ioread": ?,
                      "readrows": ?,
                      "rows": ?
                    }
                  }
                }
              }
            },
            "probe": {
              "time": ?,
              "probe_time": ?,
              "fetch": ?,
              "fetch_time": ?,
              "ioread": ?,
              "readkeys": ?,
              "rows": ?,
              "max_collisions": ?,
              "input": {
                "SELECT": {
                  "time": ?,
                  "fetch": ?,
                  "fetch_time": ?,
                  "ioread": ?,
                  "SCAN": {
                    "access": "table (dba.ta)",
                    "heap": {
                      "time": ?,
                      "fetch": ?,
                      "ioread": ?,
                      "readrows": ?,
                      "rows": ?
                    }
                  }
                }
              }
            }
          }
        }
      ]
    }
  }
}     

===================================================
0
===================================================
0
===================================================
0
